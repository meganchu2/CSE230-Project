{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE FlexibleInstances #-}

import Test.QuickCheck
--import Language.Haskell.TH
import Test.Tasty
--import Common
import Prelude
import Data.List
import Linear.V2 (V2(..), _x, _y)
import Control.Lens hiding ((<|), (|>), (:>), (:<))



import Constants
import FlappyBird
import FlappyBirdTypes
import UI hiding (main)

-- tests must start with prop_ and must return bool
-- can take any number of arguments
-- arguments are randomly generated by quickcheck when running tests

-- allow random generation of Coord type for testing
instance Arbitrary Coord where
   arbitrary = do
     Positive x <- arbitrary
     Positive y <- arbitrary
     return $ V2 x y

-- Constants.hs-----------------------------
prop_height::Bool
prop_height = height == 30

prop_width::Bool
prop_width = width == 50

prop_barrierInterval::Bool
prop_barrierInterval = barrierInterval > 0 && barrierInterval < div width 2

prop_barrierOpeningWidth::Bool
prop_barrierOpeningWidth = barrierOpeningWidth > 0 && barrierOpeningWidth < div height 2

prop_barrierNum::Bool
prop_barrierNum = barrierNum > 0

-- make sure getLo and getHi are giving reasonable values
prop_getLo::Int -> Int -> Bool
prop_getLo a b = if a > 0 && b > 1
                   then getLo a b < a && getLo a b >= 0
                   else True
prop_getHi::Int -> Int -> Bool
prop_getHi a b = if a > 0 && b > 0
                   then if a > b then getHi a b > 0 else getHi a b <= 0
                   else True


prop_gameSpeed::Bool
prop_gameSpeed = gameSpeed > 0

--------------------------------------------

-- FlappyBird.hs----------------------------

--output is bool
prop_isCoordOnAnyBarrier1::Barriers -> Coord -> Bool
prop_isCoordOnAnyBarrier1 bs c = case (isCoordOnAnyBarrier bs c) of
                                    True -> True
                                    False -> True
                                    _ -> False

--outputted bool is correct
prop_isCoordOnAnyBarrier2::Barriers -> Coord -> Bool
prop_isCoordOnAnyBarrier2 bs c = (isCoordOnAnyBarrier bs c) == ((length (filter (==c) (intercalate [] bs))) > 0)

--no coord in barrier has different x value
prop_getBarrier1::Int -> Int -> Bool
prop_getBarrier1 x y = length (filter (/=x) (map (\v -> v ^._x) (getBarrier x y))) == 0

--no coord in barrier has y values not in opening
prop_getBarrier2::Int -> Int -> Bool
prop_getBarrier2 x y = length (filter (\val -> val >= (y-barrierOpeningWidth) && val <= (y+barrierOpeningWidth)) 
                                      (map (\v -> v ^._y) 
                                      (getBarrier x y))) == 0

--outputted Barriers is correct
prop_getBarriers:: [Int] -> [Int] -> Bool
prop_getBarriers a b = if length a == length b 
                         then getBarriers a b == zipWith getBarrier a b
                         else True

--move
--maybeDie
--step
--removeOldBarriers
--replenishBarriers
--moveBarriers
--updateScore
--initGame
--turn
--nextPosition


--------------------------------------------

-- UI.hs -----------------------------------
-- handleEvent
-- drawUI
-- drawStats
-- drawScore
-- drawGameOver
-- drawGrid
-- drawCell
--------------------------------------------

prop_dummyTestShouldFail::Bool
prop_dummyTestShouldFail = 1==2

return []
main =  $forAllProperties quickCheckResult          


